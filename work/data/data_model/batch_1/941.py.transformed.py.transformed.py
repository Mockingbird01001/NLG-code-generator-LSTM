
"""
Rules for building C/API module with f2py2e.
Here is a skeleton of a new wrapper function (13Dec2001):
wrapper_function(args)
  declarations
  get_python_arguments, say, `a' and `b'
  get_a_from_python
  if (successful) {
    get_b_from_python
    if (successful) {
      callfortran
      if (successful) {
        put_a_to_python
        if (successful) {
          put_b_to_python
          if (successful) {
            buildvalue = ...
          }
        }
      }
    }
    cleanup_b
  }
  cleanup_a
  return buildvalue
Copyright 1999,2000 Pearu Peterson all rights reserved,
Pearu Peterson <pearu@ioc.ee>
Permission to use, modify, and distribute this software is given under the
terms of the NumPy License.
NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.
$Date: 2005/08/30 08:58:42 $
Pearu Peterson
"""
import os
import time
import copy
from . import __version__
f2py_version = __version__.version
numpy_version = __version__.version
from .auxfuncs import (
    applyrules, debugcapi, dictappend, errmess, gentitle, getargs2,
    hascallstatement, hasexternals, hasinitvalue, hasnote, hasresultnote,
    isarray, isarrayofstrings, iscomplex, iscomplexarray,
    iscomplexfunction, iscomplexfunction_warn, isdummyroutine, isexternal,
    isfunction, isfunction_wrap, isint1array, isintent_aux, isintent_c,
    isintent_callback, isintent_copy, isintent_hide, isintent_inout,
    isintent_nothide, isintent_out, isintent_overwrite, islogical,
    islong_complex, islong_double, islong_doublefunction, islong_long,
    islong_longfunction, ismoduleroutine, isoptional, isrequired, isscalar,
    issigned_long_longarray, isstring, isstringarray, isstringfunction,
    issubroutine, issubroutine_wrap, isthreadsafe, isunsigned,
    isunsigned_char, isunsigned_chararray, isunsigned_long_long,
    isunsigned_long_longarray, isunsigned_short, isunsigned_shortarray,
    l_and, l_not, l_or, outmess, replace, stripcomma, requiresf90wrapper
)
from . import capi_maps
from . import cfuncs
from . import common_rules
from . import use_rules
from . import f90mod_rules
from . import func2subr
options = {}
sepdict = {}
for k in ['decl',
          'frompyobj',
          'cleanupfrompyobj',
          'topyarr', 'method',
          'pyobjfrom', 'closepyobjfrom',
          'freemem',
          'userincludes',
          'includes0', 'includes', 'typedefs', 'typedefs_generated',
          'cppmacros', 'cfuncs', 'callbacks',
          'latexdoc',
          'restdoc',
          'routine_defs', 'externroutines',
          'initf2pywraphooks',
          'commonhooks', 'initcommonhooks',
          'f90modhooks', 'initf90modhooks']:
    sepdict[k] = '\n'
generationtime = int(os.environ.get('SOURCE_DATE_EPOCH', time.time()))
module_rules = {
    'modulebody': """\
 * f2py is a Fortran to Python Interface Generator (FPIG), Second Edition,
 * written by Pearu Peterson <pearu@cens.ioc.ee>.
 * Generation date:
 * Do not edit this file directly unless you know what you are doing!!!
 */
extern \"C\" {
/* See f2py2e/rules.py */
static FortranDataDef f2py_routine_defs[] = {
\t{NULL}
};
static PyMethodDef f2py_module_methods[] = {
\t{NULL,NULL}
};
static struct PyModuleDef moduledef = {
\tPyModuleDef_HEAD_INIT,
\tNULL,
\t-1,
\tf2py_module_methods,
\tNULL,
\tNULL,
\tNULL,
\tNULL
};
\tint i;
\tPyObject *m,*d, *s, *tmp;
\tPy_SET_TYPE(&PyFortran_Type, &PyType_Type);
\timport_array();
\tif (PyErr_Occurred())
\td = PyModule_GetDict(m);
\tPyDict_SetItemString(d, \"__version__\", s);
\tPy_DECREF(s);
\ts = PyUnicode_FromString(
\tPyDict_SetItemString(d, \"__doc__\", s);
\tPy_DECREF(s);
\ts = PyUnicode_FromString(\\");
\tPyDict_SetItemString(d, \"__f2py_numpy_version__\", s);
\tPy_DECREF(s);
\t/*
\t * Store the error object inside the dict, so that it could get deallocated.
\t * (in practice, this is a module, so it likely will not and cannot.)
\t */
\tfor(i=0;f2py_routine_defs[i].name!=NULL;i++) {
\t\ttmp = PyFortranObject_NewAsAttr(&f2py_routine_defs[i]);
\t\tPyDict_SetItemString(d, f2py_routine_defs[i].name, tmp);
\t\tPy_DECREF(tmp);
\t}
\tif (! PyErr_Occurred())
\treturn m;
}
}
                           PyObject *capi_args,
                           PyObject *capi_keywds,
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
f2py_start_clock();
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\\
/*end of frompyobj*/
f2py_start_call_clock();
if (PyErr_Occurred())
  f2py_success = 0;
f2py_stop_call_clock();
/*end of callfortranroutine*/
        if (f2py_success) {
/*end of pyobjfrom*/
        CFUNCSMESS(\"Building return value.\\n\");
/*closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
    } else {
    }
    CFUNCSMESS(\"Freeing memory.\\n\");
f2py_stop_clock();
    return capi_buildvalue;
}],
                ]
}
rout_rules = [
    {
        'separatorsfor': {'callfortranroutine': '\n', 'routdebugenter': '\n', 'decl': '\n',
                          'routdebugleave': '\n', 'routdebugfailure': '\n',
                          'setjmpbuf': ' || ',
                          'docstrreq': '\n', 'docstropt': '\n', 'docstrout': '\n',
                          'docstrcbs': '\n', 'docstrsigns': '\\n"\n"',
                          'latexdocstrsigns': '\n',
                          'latexdocstrreq': '\n', 'latexdocstropt': '\n',
                          'latexdocstrout': '\n', 'latexdocstrcbs': '\n',
                          },
        'kwlist': '', 'kwlistopt': '', 'callfortran': '', 'callfortranappend': '',
        'docsign': '', 'docsignopt': '', 'decl': '/*decl*/',
        'freemem': '/*freemem*/',
        'docsignshort': '', 'docsignoptshort': '',
        'docstrsigns': '', 'latexdocstrsigns': '',
        'docstrreq': '\\nParameters\\n----------',
        'docstropt': '\\nOther Parameters\\n----------------',
        'docstrout': '\\nReturns\\n-------',
        'docstrcbs': '\\nNotes\\n-----\\nCall-back functions::\\n',
        'latexdocstrreq': '\\noindent Required arguments:',
        'latexdocstropt': '\\noindent Optional arguments:',
        'latexdocstrout': '\\noindent Return objects:',
        'latexdocstrcbs': '\\noindent Call-back functions:',
        'args_capi': '', 'keys_capi': '', 'functype': '',
        'frompyobj': '/*frompyobj*/',
        'cleanupfrompyobj': ['/*end of cleanupfrompyobj*/'],
        'pyobjfrom': '/*pyobjfrom*/',
        'closepyobjfrom': ['/*end of closepyobjfrom*/'],
        'topyarr': '/*topyarr*/', 'routdebugleave': '/*routdebugleave*/',
        'routdebugenter': '/*routdebugenter*/',
        'routdebugfailure': '/*routdebugfailure*/',
        'callfortranroutine': '/*callfortranroutine*/',
        'argformat': '', 'keyformat': '', 'need_cfuncs': '',
        'docreturn': '', 'return': '', 'returnformat': '', 'rformat': '',
        'kwlistxa': '', 'keys_xa': '', 'xaformat': '', 'docsignxa': '', 'docsignxashort': '',
        'initf2pywraphook': '',
    }, {
        'decl': '',
        '_check': l_not(ismoduleroutine)
    }, {
        'decl': '',
        '_check': ismoduleroutine
    }, {
        'functype': 'void',
                               ismoduleroutine: '',
                               isdummyroutine: ''
                               },
                        },
        'need': {l_and(l_not(l_or(ismoduleroutine, isintent_c)), l_not(isdummyroutine)): 'F_FUNC'},
        'callfortranroutine': [
            {debugcapi: [
            {hasexternals:},
            {isthreadsafe: '\t\t\tPy_BEGIN_ALLOW_THREADS'},
            {l_not(l_or(hascallstatement, isdummyroutine))
            {isthreadsafe: '\t\t\tPy_END_ALLOW_THREADS'},
            {hasexternals: }
        ],
        '_check': l_and(issubroutine, l_not(issubroutine_wrap)),
    }, {
        'functype': 'void',
                               isdummyroutine: '',
                               },
                        },
        'initf2pywraphook': {l_not(l_or(ismoduleroutine, isdummyroutine)): '''
    {
      PyObject_SetAttrString(o,"_cpointer", tmp);
      Py_DECREF(tmp);
      PyObject_SetAttrString(o,"__name__", s);
      Py_DECREF(s);
    }
    '''},
        'need': {l_not(l_or(ismoduleroutine, isdummyroutine)): ['F_WRAPPEDFUNC', 'F_FUNC']},
        'callfortranroutine': [
            {debugcapi: [
            {hasexternals:},
            {isthreadsafe: '\tPy_BEGIN_ALLOW_THREADS'},
            {l_not(l_or(hascallstatement, isdummyroutine))
            {hascallstatement:
            {isthreadsafe: '\tPy_END_ALLOW_THREADS'},
            {hasexternals: '\t}'}
        ],
        '_check': isfunction_wrap,
    }, {
        'functype': 'void',
                               isdummyroutine: '',
                               },
                        },
        'initf2pywraphook': {l_not(l_or(ismoduleroutine, isdummyroutine)): '''
    {
      PyObject_SetAttrString(o,"_cpointer", tmp);
      Py_DECREF(tmp);
      PyObject_SetAttrString(o,"__name__", s);
      Py_DECREF(s);
    }
    '''},
        'need': {l_not(l_or(ismoduleroutine, isdummyroutine)): ['F_WRAPPEDFUNC', 'F_FUNC']},
        'callfortranroutine': [
            {debugcapi: [
            {hasexternals:},
            {isthreadsafe: '\tPy_BEGIN_ALLOW_THREADS'},
            {l_not(l_or(hascallstatement, isdummyroutine))
            {hascallstatement:
            {isthreadsafe: '\tPy_END_ALLOW_THREADS'},
            {hasexternals: '\t}'}
        ],
        '_check': issubroutine_wrap,
    }, {
        'callfortranroutine': [{l_and(debugcapi, isstringfunction):},
                               {l_and(debugcapi, l_not(isstringfunction)):}
                               ],
        '_check': l_and(isfunction, l_not(isfunction_wrap))
    }, {
                               isdummyroutine: ''
                               },
                        },
                 {iscomplexfunction:
                 ],
        'callfortranroutine': [
            {hasexternals:},
            {isthreadsafe: '\tPy_BEGIN_ALLOW_THREADS'},
'''},
            {l_not(l_or(hascallstatement, isdummyroutine))
            {isthreadsafe: '\tPy_END_ALLOW_THREADS'},
            {hasexternals: '\t}'},
            {l_and(debugcapi, iscomplexfunction)
        'need': [{l_not(isdummyroutine): 'F_FUNC'},
                 {islong_longfunction: 'long_long'},
                 {islong_doublefunction: 'long_double'}],
        '_check': l_and(isfunction, l_not(isstringfunction), l_not(isfunction_wrap))
    }, {
        'routine_def': {l_not(l_or(ismoduleroutine, isintent_c)):
                        l_and(l_not(ismoduleroutine), isintent_c):
                        },
                              '\t\tPyErr_SetString(PyExc_MemoryError, \"out of memory\");',
                              '\t\tf2py_success = 0;',
                              '\t} else {',
                              '\t}',
                              '\tif (f2py_success) {',
                              {hasexternals:,
                              {isthreadsafe: '\t\tPy_END_ALLOW_THREADS'},
                              {hasexternals: '\t\t}'},
                              {debugcapi:
                              '\t} /* if (f2py_success) after (string)malloc */',
                              ],
        '_check':l_and(isstringfunction, l_not(isfunction_wrap))
    },
    {
        '_check': debugcapi
    }
]
typedef_need_dict = {islong_long: 'long_long',
                     islong_double: 'long_double',
                     islong_complex: 'complex_long_double',
                     isunsigned_char: 'unsigned_char',
                     isunsigned_short: 'unsigned_short',
                     isunsigned: 'unsigned',
                     isunsigned_long_long: 'unsigned_long_long',
                     isunsigned_chararray: 'unsigned_char',
                     isunsigned_shortarray: 'unsigned_short',
                     isunsigned_long_longarray: 'unsigned_long_long',
                     issigned_long_longarray: 'long_long',
                     }
aux_rules = [
    {
        'separatorsfor': sepdict
    },
    {
        'need': typedef_need_dict,
    },
    {
        'need': {hasinitvalue: 'math.h'},
        '_check': l_and(isscalar, l_not(iscomplex)),
    },
    {
        '_check': l_and(isscalar, l_not(iscomplex), isintent_out),
    },
    {
        '_check': iscomplex
    },
    {
                 ],
        'need':['len..'],
        '_check':isstring
    },
    {
                 ],
        'need':['len..', {hasinitvalue: 'forcomb'}, {hasinitvalue: 'CFUNCSMESS'}],
        '_check': isarray
    },
    {
        '_check': l_and(isarray, l_not(iscomplexarray))
    }, {
        '_check': l_and(isarray, l_not(iscomplexarray), isintent_nothide)
    },
     '_check': isint1array,
     '_depend': ''
     },
     '_check': isunsigned_chararray,
     '_depend': ''
     },
     '_check': isunsigned_shortarray,
     '_depend': ''
     },
     '_check': isunsigned_long_longarray,
     '_depend': ''
     },
     '_check': iscomplexarray,
     '_depend': ''
     },
    {
        'need': 'string',
        '_check': isstringarray
    }
]
arg_rules = [
    {
        'separatorsfor': sepdict
    },
    {
        '_depend': '',
        'need': typedef_need_dict,
    },
    {
                                           l_and(hasnote, isintent_nothide): '--- See above.'}]},
        'depend': ''
    },
    {
        '_check': l_and(isintent_nothide, l_not(isoptional))
    },
    {
        '_check': l_and(isintent_nothide, isoptional)
    },
    {
        '_check': isintent_out
    },
    {
                 {l_not(isintent_callback):
                 ],
        'argformat': {isrequired: 'O'},
        'keyformat': {isoptional: 'O'},
        'xaformat': {isintent_nothide: 'O!'},
        '_check':isexternal
    },
    {
        'frompyobj': [{l_not(isintent_callback): """\
} else {
}
\
        if (capi_tmp) {
          Py_DECREF(capi_tmp);
        }
        else {
        }
          return NULL;
        }
      }
    }
  }
    return NULL;
  }
},
        'need': ['SWAP', 'create_cb_arglist'],
        '_check':isexternal,
        '_depend':''
    },
    {
        '_check': l_and(isscalar, l_not(iscomplex))
    }, {
        'need': {hasinitvalue: 'math.h'},
        '_check': l_and(isscalar, l_not(iscomplex)),
    }, {
        'argformat': {isrequired: 'O'},
        'keyformat': {isoptional: 'O'},
        'pyobjfrom': {isintent_inout: """\
\tif (f2py_success) {"""},
        '_check': l_and(isscalar, l_not(iscomplex), isintent_nothide)
    }, {
        'frompyobj': [
             '_depend': ''},
             '_depend': ''},
            {l_not(islogical): '''\
\tif (f2py_success) {'''},
            {islogical: '''\
\t\tf2py_success = 1;
\tif (f2py_success) {'''},
        ],
        '_check': l_and(isscalar, l_not(iscomplex), isintent_nothide),
        '_depend': ''
    }, {
        'need': typedef_need_dict,
        '_check': l_and(isscalar, l_not(iscomplex), isintent_hide),
        '_depend': ''
    }, {
        '_check': l_and(isscalar, l_not(iscomplex)),
        '_depend': ''
    },
    {
        '_check': iscomplex
    }, {
        'argformat': {isrequired: 'O'},
        'keyformat': {isoptional: 'O'},
        'pyobjfrom': {isintent_inout: """\
\t\tif (f2py_success) {"""},
        '_check': l_and(iscomplex, isintent_nothide)
    }, {
                      {l_and(isoptional, l_not(hasinitvalue))
                      '\n\tif (f2py_success) {'],
        '_check': l_and(iscomplex, isintent_nothide),
        '_depend': ''
    }, {
        '_check': l_and(iscomplex, isintent_hide)
    }, {
        '_check': l_and(iscomplex, isintent_hide),
        '_depend': ''
    }, {
        '_check': iscomplex
    }, {
        '_check': iscomplex,
        '_depend': ''
    },
    {
        'need': ['len..'],
        '_check':isstring
    }, {
        'frompyobj': """\
\tif (f2py_success) \
        '_check':isstring,
        '_depend':''
    }, {
        'argformat': {isrequired: 'O'},
        'keyformat': {isoptional: 'O'},
        'pyobjfrom': {isintent_inout: '''\
\tif (f2py_success) {'''},
        '_check': l_and(isstring, isintent_nothide)
    }, {
        '_check': l_and(isstring, isintent_hide)
    }, {
        '_check': isstring,
        '_depend': ''
    },
    {
                 ],
        'need': 'len..',
        '_check': isarray
    }, {
        'xaformat': 'i',
        '_check': l_and(isarray, isintent_overwrite),
    }, {
        '_check': l_and(isarray, isintent_overwrite),
        '_depend': '',
    },
    {
        'xaformat': 'i',
        '_check': l_and(isarray, isintent_copy),
    }, {
        '_check': l_and(isarray, isintent_copy),
        '_depend': '',
    }, {
        'need': [{hasinitvalue: 'forcomb'}, {hasinitvalue: 'CFUNCSMESS'}],
        '_check': isarray,
        '_depend': ''
    }, {
        'argformat': {isrequired: 'O'},
        'keyformat': {isoptional: 'O'},
        '_check': l_and(isarray, isintent_nothide)
    }, {
                      {isintent_hide:
                      {isintent_nothide:
                      """\
\t\tPyObject *exc, *val, *tb;
\t\tPyErr_Fetch(&exc, &val, &tb);
\t\tnpy_PyErr_ChainExceptionsCause(exc, val, tb);
\t} else {\
\t\tint *_i,capi_i=0;
\t\t\twhile ((_i = nextforcomb()))
\t\t} else {
\t\t\tPyObject *exc, *val, *tb;
\t\t\tPyErr_Fetch(&exc, &val, &tb);
\t\t\tnpy_PyErr_ChainExceptionsCause(exc, val, tb);
\t\t\tf2py_success = 0;
\t\t}
\t}
\tif (f2py_success) {"""]},
                      ],
        'cleanupfrompyobj': [
            {l_not(l_or(isintent_out, isintent_hide)): """\
            {l_and(isintent_hide, l_not(isintent_out))
        ],
        '_check': isarray,
        '_depend': ''
    },
    {
        '_check': l_and(isarray, l_not(iscomplexarray))
    }, {
        '_check': l_and(isarray, l_not(iscomplexarray), isintent_nothide)
    },
     '_check': isint1array,
     '_depend': ''
     },
     '_check': isunsigned_chararray,
     '_depend': ''
     },
     '_check': isunsigned_shortarray,
     '_depend': ''
     },
     '_check': isunsigned_long_longarray,
     '_depend': ''
     },
     '_check': iscomplexarray,
     '_depend': ''
     },
    {
        'need': 'string',
        '_check': isstringarray
    }
]
check_rules = [
    {
        'need': 'len..'
    }, {
        'need': 'CHECKSCALAR',
        '_check': l_and(isscalar, l_not(iscomplex)),
        '_break': ''
    }, {
        'need': 'CHECKSTRING',
        '_check': isstring,
        '_break': ''
    }, {
        'need': 'CHECKARRAY',
        '_check': isarray,
        '_break': ''
    }, {
        'need': 'CHECKGENERIC',
    }
]
def buildmodule(m, um):
    outmess('\tBuilding module "%s"...\n' % (m['name']))
    ret = {}
    mod_rules = defmod_rules[:]
    vrd = capi_maps.modsign2map(m)
    rd = dictappend({'f2py_version': f2py_version}, vrd)
    funcwrappers = []
    funcwrappers2 = []
    for n in m['interfaced']:
        nb = None
        for bi in m['body']:
            if not bi['block'] == 'interface':
                errmess('buildmodule: Expected interface block. Skipping.\n')
                continue
            for b in bi['body']:
                if b['name'] == n:
                    nb = b
                    break
        if not nb:
            errmess(
                'buildmodule: Could not found the body of interfaced routine "%s". Skipping.\n' % (n))
            continue
        nb_list = [nb]
        if 'entry' in nb:
            for k, a in nb['entry'].items():
                nb1 = copy.deepcopy(nb)
                del nb1['entry']
                nb1['name'] = k
                nb1['args'] = a
                nb_list.append(nb1)
        for nb in nb_list:
            isf90 = requiresf90wrapper(nb)
            api, wrap = buildapi(nb)
            if wrap:
                if isf90:
                    funcwrappers2.append(wrap)
                else:
                    funcwrappers.append(wrap)
            ar = applyrules(api, vrd)
            rd = dictappend(rd, ar)
    cr, wrap = common_rules.buildhooks(m)
    if wrap:
        funcwrappers.append(wrap)
    ar = applyrules(cr, vrd)
    rd = dictappend(rd, ar)
    mr, wrap = f90mod_rules.buildhooks(m)
    if wrap:
        funcwrappers2.append(wrap)
    ar = applyrules(mr, vrd)
    rd = dictappend(rd, ar)
    for u in um:
        ar = use_rules.buildusevars(u, m['use'][u['name']])
        rd = dictappend(rd, ar)
    needs = cfuncs.get_needs()
    code = {}
    for n in needs.keys():
        code[n] = []
        for k in needs[n]:
            c = ''
            if k in cfuncs.includes0:
                c = cfuncs.includes0[k]
            elif k in cfuncs.includes:
                c = cfuncs.includes[k]
            elif k in cfuncs.userincludes:
                c = cfuncs.userincludes[k]
            elif k in cfuncs.typedefs:
                c = cfuncs.typedefs[k]
            elif k in cfuncs.typedefs_generated:
                c = cfuncs.typedefs_generated[k]
            elif k in cfuncs.cppmacros:
                c = cfuncs.cppmacros[k]
            elif k in cfuncs.cfuncs:
                c = cfuncs.cfuncs[k]
            elif k in cfuncs.callbacks:
                c = cfuncs.callbacks[k]
            elif k in cfuncs.f90modhooks:
                c = cfuncs.f90modhooks[k]
            elif k in cfuncs.commonhooks:
                c = cfuncs.commonhooks[k]
            else:
                errmess('buildmodule: unknown need %s.\n' % (repr(k)))
                continue
            code[n].append(c)
    mod_rules.append(code)
    for r in mod_rules:
        if ('_check' in r and r['_check'](m)) or ('_check' not in r):
            ar = applyrules(r, vrd, m)
            rd = dictappend(rd, ar)
    ar = applyrules(module_rules, rd)
    fn = os.path.join(options['buildpath'], vrd['coutput'])
    ret['csrc'] = fn
    with open(fn, 'w') as f:
        f.write(ar['modulebody'].replace('\t', 2 * ' '))
    outmess('\tWrote C/API module "%s" to file "%s"\n' % (m['name'], fn))
    if options['dorestdoc']:
        fn = os.path.join(
            options['buildpath'], vrd['modulename'] + 'module.rest')
        with open(fn, 'w') as f:
            f.write('.. -*- rest -*-\n')
            f.write('\n'.join(ar['restdoc']))
        outmess('\tReST Documentation is saved to file "%s/%smodule.rest"\n' %
                (options['buildpath'], vrd['modulename']))
    if options['dolatexdoc']:
        fn = os.path.join(
            options['buildpath'], vrd['modulename'] + 'module.tex')
        ret['ltx'] = fn
        with open(fn, 'w') as f:
            f.write(
                '%% This file is auto-generated with f2py (version:%s)\n' % (f2py_version))
            if 'shortlatex' not in options:
                f.write(
                    '\\documentclass{article}\n\\usepackage{a4wide}\n\\begin{document}\n\\tableofcontents\n\n')
                f.write('\n'.join(ar['latexdoc']))
            if 'shortlatex' not in options:
                f.write('\\end{document}')
        outmess('\tDocumentation is saved to file "%s/%smodule.tex"\n' %
                (options['buildpath'], vrd['modulename']))
    if funcwrappers:
        wn = os.path.join(options['buildpath'], vrd['f2py_wrapper_output'])
        ret['fsrc'] = wn
        with open(wn, 'w') as f:
            f.write('C     -*- fortran -*-\n')
            f.write(
                'C     This file is autogenerated with f2py (version:%s)\n' % (f2py_version))
            f.write(
                'C     It contains Fortran 77 wrappers to fortran functions.\n')
            lines = []
            for l in ('\n\n'.join(funcwrappers) + '\n').split('\n'):
                if 0 <= l.find('!') < 66:
                    lines.append(l + '\n')
                elif l and l[0] == ' ':
                    while len(l) >= 66:
                        lines.append(l[:66] + '\n     &')
                        l = l[66:]
                    lines.append(l + '\n')
                else:
                    lines.append(l + '\n')
            lines = ''.join(lines).replace('\n     &\n', '\n')
            f.write(lines)
        outmess('\tFortran 77 wrappers are saved to "%s"\n' % (wn))
    if funcwrappers2:
        wn = os.path.join(
            options['buildpath'], '%s-f2pywrappers2.f90' % (vrd['modulename']))
        ret['fsrc'] = wn
        with open(wn, 'w') as f:
            f.write('!     -*- f90 -*-\n')
            f.write(
                '!     This file is autogenerated with f2py (version:%s)\n' % (f2py_version))
            f.write(
                '!     It contains Fortran 90 wrappers to fortran functions.\n')
            lines = []
            for l in ('\n\n'.join(funcwrappers2) + '\n').split('\n'):
                if 0 <= l.find('!') < 72:
                    lines.append(l + '\n')
                elif len(l) > 72 and l[0] == ' ':
                    lines.append(l[:72] + '&\n     &')
                    l = l[72:]
                    while len(l) > 66:
                        lines.append(l[:66] + '&\n     &')
                        l = l[66:]
                    lines.append(l + '\n')
                else:
                    lines.append(l + '\n')
            lines = ''.join(lines).replace('\n     &\n', '\n')
            f.write(lines)
        outmess('\tFortran 90 wrappers are saved to "%s"\n' % (wn))
    return ret
stnd = {1: 'st', 2: 'nd', 3: 'rd', 4: 'th', 5: 'th',
        6: 'th', 7: 'th', 8: 'th', 9: 'th', 0: 'th'}
def buildapi(rout):
    rout, wrap = func2subr.assubr(rout)
    args, depargs = getargs2(rout)
    capi_maps.depargs = depargs
    var = rout['vars']
    if ismoduleroutine(rout):
        outmess('\t\t\tConstructing wrapper function "%s.%s"...\n' %
                (rout['modulename'], rout['name']))
    else:
        outmess('\t\tConstructing wrapper function "%s"...\n' % (rout['name']))
    vrd = capi_maps.routsign2map(rout)
    rd = dictappend({}, vrd)
    for r in rout_rules:
        if ('_check' in r and r['_check'](rout)) or ('_check' not in r):
            ar = applyrules(r, vrd, rout)
            rd = dictappend(rd, ar)
    nth, nthk = 0, 0
    savevrd = {}
    for a in args:
        vrd = capi_maps.sign2map(a, var[a])
        if isintent_aux(var[a]):
            _rules = aux_rules
        else:
            _rules = arg_rules
            if not isintent_hide(var[a]):
                if not isoptional(var[a]):
                    nth = nth + 1
                    vrd['nth'] = repr(nth) + stnd[nth % 10] + ' argument'
                else:
                    nthk = nthk + 1
                    vrd['nth'] = repr(nthk) + stnd[nthk % 10] + ' keyword'
            else:
                vrd['nth'] = 'hidden'
        savevrd[a] = vrd
        for r in _rules:
            if '_depend' in r:
                continue
            if ('_check' in r and r['_check'](var[a])) or ('_check' not in r):
                ar = applyrules(r, vrd, var[a])
                rd = dictappend(rd, ar)
                if '_break' in r:
                    break
    for a in depargs:
        if isintent_aux(var[a]):
            _rules = aux_rules
        else:
            _rules = arg_rules
        vrd = savevrd[a]
        for r in _rules:
            if '_depend' not in r:
                continue
            if ('_check' in r and r['_check'](var[a])) or ('_check' not in r):
                ar = applyrules(r, vrd, var[a])
                rd = dictappend(rd, ar)
                if '_break' in r:
                    break
        if 'check' in var[a]:
            for c in var[a]['check']:
                vrd['check'] = c
                ar = applyrules(check_rules, vrd, var[a])
                rd = dictappend(rd, ar)
    if isinstance(rd['cleanupfrompyobj'], list):
        rd['cleanupfrompyobj'].reverse()
    if isinstance(rd['closepyobjfrom'], list):
        rd['closepyobjfrom'].reverse()
                                            {'docsign': rd['docsign'],
                                             'docsignopt': rd['docsignopt'],
                                             'docsignxa': rd['docsignxa']}))
                                 {'docsignxa': rd['docsignxashort'],
                                  'docsignopt': rd['docsignoptshort']}
                                 ))
    if optargs == '':
        rd['docsignatureshort'] = stripcomma(
    else:
                                          {'docsign': rd['docsign'],
                                           'docsignopt': optargs,
                                           })
    rd['latexdocsignatureshort'] = rd['docsignatureshort'].replace('_', '\\_')
    rd['latexdocsignatureshort'] = rd[
        'latexdocsignatureshort'].replace(',', ', ')
                     'callfortran': rd['callfortran'], 'callfortranappend': rd['callfortranappend']}))
    if len(rd['callfortranappend']) > 1:
                                             'callfortran': rd['callfortran'], 'callfortranappend': rd['callfortranappend']}))
    else:
        rd['callcompaqfortran'] = cfs
    rd['callfortran'] = cfs
    if isinstance(rd['docreturn'], list):
        rd['docreturn'] = stripcomma(
    rd['docstrsigns'] = []
    rd['latexdocstrsigns'] = []
    for k in ['docstrreq', 'docstropt', 'docstrout', 'docstrcbs']:
        if k in rd and isinstance(rd[k], list):
            rd['docstrsigns'] = rd['docstrsigns'] + rd[k]
        k = 'latex' + k
        if k in rd and isinstance(rd[k], list):
            rd['latexdocstrsigns'] = rd['latexdocstrsigns'] + rd[k][0:1] +                ['\\begin{description}'] + rd[k][1:] +                ['\\end{description}']
    ar = applyrules(routine_rules, rd)
    if ismoduleroutine(rout):
        outmess('\t\t\t  %s\n' % (ar['docshort']))
    else:
        outmess('\t\t  %s\n' % (ar['docshort']))
    return ar, wrap
